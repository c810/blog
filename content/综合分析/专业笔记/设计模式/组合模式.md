---
title: 组合模式
publish: true
---

## 一、前言

往往很多大需求都是通过增删改查堆出来的，今天要一个需求 `if` 一下，明天加个内容 `else` 扩展一下。日积月累需求也就越来越大，扩展和维护的成本也就越来越高。往往大部分研发是不具备产品思维和整体业务需求导向的，总以为写好代码完成功能即可。但这样的不考虑扩展性的实现，很难让后续的需求都快速迭代，久而久之就会被陷入恶性循环，每天都有 bug 要改。

## 二、组合模式介绍

![[Pasted image 20241015113304.png]]

从上图可以看到这有点像螺丝🔩和螺母，通过一堆的链接组织出一棵结构树。而这种通过把相似对象 (*也可以称作是方法*) 组合成一组可被调用的结构树对象的设计思路叫做组合模式。

这种设计方式可以让你的服务组节点进行自由组合对外提供服务，例如你有三个原子校验功能 (`A：身份证`、`B：银行卡`、`C：手机号`) 服务并对外提供调用使用。有些调用方需要使用 AB 组合，有些调用方需要使用到 CBA 组合，还有一些可能只使用三者中的一个。那么这个时候你就可以使用组合模式进行构建服务，对于不同类型的调用方配置不同的组织关系树，而这个树结构你可以配置到数据库中也可以不断的通过图形界面来控制树结构。

所以不同的设计模式用在恰当好处的场景可以让代码逻辑非常清晰并易于扩展，同时也可以减少团队新增人员对项目的学习成本。

## 三、案例场景模拟

![[Pasted image 20241015113351.png]]

以上是一个非常简化版的营销规则 `决策树`，根据 `性别`、`年龄` 来发放不同类型的优惠券，来刺激消费起到精准用户促活的目的。

虽然一部分小伙伴可能并没有开发过营销场景，但你可能时时刻刻的被营销着。比如你去经常浏览男性喜欢的机械键盘、笔记本电脑、汽车装饰等等，那么就给你推荐此类的优惠券刺激你消费。那么如果你购物不多，或者钱不在自己手里。那么你是否打过车，有一段时间经常有小伙伴喊，为什么同样的距离他就 10 元，我就 15 元呢？其实这些都是被营销的案例，一般对于不常使用软件的小伙伴，经常会进行稍微大力度的促活，增加用户粘性。

那么在这里我们就模拟一个类似的决策场景，体现出组合模式在其中起到的重要性。另外，组合模式不只是可以运用于规则决策树，还可以做服务包装将不同的接口进行组合配置，对外提供服务能力，减少开发成本。

## 四、用原始代码实现

```java
public class EngineController {

    private Logger logger = LoggerFactory.getLogger(EngineController.class);

    public String process(final String userId, final String userSex, final int userAge) {

        logger.info("ifelse实现方式判断用户结果。userId：{} userSex：{} userAge：{}", userId, userSex, userAge);

        if ("man".equals(userSex)) {
            if (userAge < 25) {
                return "果实A";
            }

            if (userAge >= 25) {
                return "果实B";
            }
        }

        if ("woman".equals(userSex)) {
            if (userAge < 25) {
                return "果实C";
            }

            if (userAge >= 25) {
                return "果实D";
            }
        }

        return null;

    }

}
```

## 五、组合模式重构代码

接下来使用组合模式来进行代码优化，也算是一次很小的重构。

接下来的重构部分代码改动量相对来说会比较大一些，为了让我们可以把不同类型的决策节点和最终的果实组装成一棵可被运行的决策树，需要做适配设计和工厂方法调用，具体会体现在定义接口以及抽象类和初始化配置决策节点（性别、年龄）上。建议这部分代码多阅读几次，最好实践下。

### 0. 图示

[Flowchart Maker & Online Diagram Software](https://viewer.diagrams.net/?tags=%7B%7D&highlight=0000ff&edit=_blank&layers=1&nav=1&title=%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.drawio#R7V1bc9s4sv41rHIe7OL98ijK8iRnnZmpJOfs7NMpWqIlbmhRS1GxPb9%2BcRdAgNSNpCiZqZlEvJPoD92NRvcHzRq%2FvP2WR6vF12wWp5qpz940614zTcsLdPAP3POO9xieZeM98zyZkX3bHd%2BTv2Oyk1w43ySzeC2cWGRZWiQrcec0Wy7jaSHsi%2FI8exVPe85S8amraB5LO75Po1Te%2B89kVizwXt%2F0tvs%2Fx8l8QZ9suAE%2B8hLRk8mXrBfRLHvldlkTzRrnWVbgXy9v4ziFrUfbBV%2F3UHGUvVgeL4t9LnAm5tf8q7N0Rutvv799%2F2v25%2Fgft%2BQuv6J0Qz74MZsn04ckLeKcvHfxThtj%2FZq8pNESbIWvi6SIv6%2BiKTz0CoQP9i2KlxRsGeAnuW2cF%2FFb5fsarBUAfuLsJS7yd3AKucAh7UaQY7tk%2B3UrBps29oIXgU1OjIjo5%2BzW29YBP0gDHdBYptRY8H7wP12bBJqva2GoTXwtnGiBoU0czXe10NImnja61wIX7gkCbeRrppuClw2fQAu7c%2FjrMVvOITpRs998L%2FIEbQMMge3%2FQ88zwTvrj8m6ANdEL7C50T1%2B5HH8O%2Bh2j8nyJzuC7gl7yvZg%2FGX5nMHLPzHpcIIFUipEAUZpMl%2BC32n8DI9ASSagV4zI7pdkNoMXh3m8Tv6OntCNdLC9ypJlgRreCTXnHt5pU2Rr3K%2FhjddFnv2Mx1ma5WDPMkNoAh%2BelnbthaBqTFfCKhBR5cigoqqHB1VrmLLqMOVr%2FkQLPQSlB4IgGVMQd2MZUyoU3RCgQWB8mWFMsfM26zinO7%2BCDi3gjJ7FX1FC2yyeJuskW35FzxtwxuMsUODM7RJnriSLeAYMHdnM8mKRzbNllE62e8M82yxn8Yy0%2BPacxyxbkVb%2Bd1wU78RqQwGIwo3fkuIvcjn8%2FS%2Fu9%2F0bv%2FFON5bgY%2F%2FiN%2F5F7wU3thehLXrVLFov0HtuTQ%2F8unrDAxoj2%2BTTuKbRiKtSRPk8PgIJeZxGRfJLfI%2FGJevJGgQohRGwQROoJqAG0ZXCf4yegLem7I1T0FTA%2Fp%2FUHys7FnHVyMVbB2lnh3NrO9ytfqcbNtGnezc9ud2f8PW5U7Ln5zUQeVk27KnHi8uWxBVG6xh5Xb3yt1xP9recQOFvOUZbOstR2EZs5WbJL2rmNFv%2FA3w3GDzE9Ch4GH%2BCfM1q85TC5tbb97t%2BYp8LYNwL934%2FdsPl03qFb6ncxTufhubfI29gAl0EhaPgaiMd%2BaUP0F3wx%2FAcoBnwySE4x0JXBfQ%2ByKuY2FqIvJC6G6JzwE5wKBhpvo0cXR39ANeCPSZSRKYWBsg9Bq4M8pNHBnoNcB%2Bwxyaes2813EzPwNqb%2Bo0oMH1J3GJ4jTXqUGYHShZochc1oAv1eTCmDRigPfewDUHbhiO4EwsiHBU5wC0vZiDR0CJe5AifF2ojB90LgQCPXoDwhKt89BgPSiu04fMADoSr5FfxobsKH8Hug8%2FBmAiRTaq5igEIwy6kP3QKspEKUuhVQ9RYAMTwHPA5Hnz6OYSXPEO4UWcYKfYbSaFQ%2BH36hIxVscmX3N474G5ALH6Z%2FchuPnGv3NSHePcN35F9gv540OtWv8ipI4cC%2Bqh9HDbYhwxPFTZYVwwb2ot5%2BHvZYLJrvYqWgtjc%2F2wyNCqNpj%2FnaDhxO8XtCFVuskyKJErxDciZzETnya%2BogOr5KcvSGN1X7FPV1lqt6n%2FKGh2%2Fr%2FgN2wH0IV2k6c8%2F2E540Db4IaecmTLkNOfII%2BaZ6HampW2oSIMH4hOEBlLOvqTJa9T%2BBKlidnKA3gedDA2YQXwUcAf4iAl9sZDq9gC%2BUt0bMi%2BBWUTpEaIbZt3DduHsWdmQApMzhjuJt1L%2FeNYuZXuGjG09pBrSsWA0UEwX0LhQREM78W2Tgt8vSfHjfRXffDqn2zIFAxnwj4HgfRa36SBTxemNu%2Fg%2FmyhdqxsWR84%2BtWGHD2lW80Ka9T4Do6v4DtjBdYx%2F8%2B7PJ%2F5qOl5SXNJnSVjXJ4n0MiVhX6skoPdwacJwrk8Y88sTxix%2BjjbwARchi2dgdeMWmuqQAe4wBq0dgxo06MsPQn3FINSkE1qND0KD1gPB0RNo9GgKpwB6MW%2FaDh77PJt6UFjEUUDSVkCyvbCIPDfxAgd%2BPdcYz9myILO1hkG2H6KXJIUN%2BzlOf8XwbcgBeq1mWve%2BrntWi%2FJlAazqwJdKvlZr8nUVs6powgPPYZRD0CxejUMiTjmUPbJV8XoSXSjAyJ0F741yDJ5c6qIZFnISxBqJRPhcqIYcfc0GLJ6ARV%2BEommbEhYtVY5Qe2BUT%2FEDHRS6JIoG5%2BMOQmUtBslE4Ii%2FBbuyEp0wk5KfAgSHRh6dZXwY8NgUHj0Zj6bXKR7lSQHDGOR7rHwt1xYdbks2flaX8jVsSZgfPhWMKvyduWAVsu4mF8xQuS0emu330AR%2BAHX%2BGZLBjup8LJRR3fWOziUz6vukfqfrlil0S5r%2BfWxqGU1TK13RXqYZhSwHhv8FQ9XRPO5Dev%2BtZYp2zWAZaMJstyrDv7WMM0Ouh2g60nD28EIb84Msnic%2BDAZGbzQ2uQ0dRLZxWIC0vRhdn2Mihl7bhcSgiMJrUOaKeK11HkdpWWiOOWmN9SJawU2iuWFDXU6ieQqtZMiyOWRDJWJiu39%2FW1prGcsmVH5QvJyNYNkbfFYarddA57ToFJkX4RSphs%2BDU1TZg2udIscRjXYjPlF3LpGpdIl%2BA70mzvvgFbE5lD45RaoatcEpasgpmiPs0Yc0m0KodrWaynr8oD6ZeVE%2BmRyq%2BzJZzlHhw9F67kQXpQE16XuimnQUxeGuqWhoQ2%2BtpeVJatzQ3%2BI1%2FG7weXk2jdfrm%2BcEuLYaKz7i9Rs9pNRzMK35W4IyQAv2k7%2Fq4xTttuU57e79fi0uDRGWiupyt9OZI1MOAWFQjrPlczK%2FaB1gOKUAkuUrJuqUiSqe31Z77xc%2FaqFcgnpSvzLwguCeccEReQDFcFOrHATSj5KGSIX7tFlEsYdPVSyS9Z34RvBE2HilF%2F0wrszZdKFZH50q6UI2CuV7p2ra0mlNGcqDv3UBhq3TXaZz%2F94xQKZJyCiSgBg6ujGfe418GYiaH0JWaLpl%2FAr%2BBjZ8uslhi3%2BO1gsJwSJU2ygjFd%2FubrXhx7UbPNXEm6oxe3VhHqqVZOmd7%2FYbHXdXvB4fEzr0DQdz0rpuULBTWKoBn9%2BabpCJPOoiXEcbmLnkybUcrRrcqD7j3lBEOkzVIKc9N8qVxDlM8131NJ9Jwhi7ebAqoiPdzPOZfWXC6t08H%2B7CtUxaOk2FaWair%2F2pPdMf1NKglg6ysB2pJUX12pB%2BUN2Fa9MPdDH94Lb%2FakkuFMMR%2BBAVTV9w%2FL08B%2Be58mxHoArwuZ7TUlejgaBuCkUrpvf2TVuonM776DWk5xuJ1ac%2FlUZiirl95eRee9TRe002AVgWQBvHM21LjAUtMALvPYPNzzi%2FqURkrzNxTphw2u5STcJl%2BSzO%2BQm4X1F%2Bc3vL7ycd7VTyLpnnm3Jr7v6YM7y5JGaMj7GAsApKVD6MTUEGM6J%2BbI%2FvEapuGReHSQ%2FTmE04QlRWKOygWklM4%2BmhMkpUPRkcxM3R2YdUw5B9UbPPRgoHLoBBsIB%2FqsEBDx48idGXDl5uxy%2BVgdLzvjJR9HBREsw%2FKooD7ObFgU85rbv2Sy4VRdQPqGwfcQyOHlroA8QmUx0Jl%2BoQGp4oRpQ5upXNUZ2hIz1SakMPUifCxVEcGIsDetAJ4TdAykLoKhKtGKJFUyC7tE50EKxvt6AC9Q2euZEG9Zr9AjDiSqEYbng5UCpezK5IeQKNY3gW227%2Fg6UEsIzpnGVxkSL%2BMiHmP%2BL3WkpOxkTB%2BpMLyadHE27GVeb7LpNF85QWHjxz5NPZ5LbJwvfbxZzffJPGsE3KnZUi5xs%2Bfpzd6hNUyo4BJgX3kYczQvLgMANk6KPQFoxx2dKyR51%2BhTC1ys9tMpmVMgWQjsViuzqpVa8etBcTsAtPxpQekPkD8YpAtYBXEAgQSXyAuqUtEIEICxSdp6MKHNGy4O%2F4uhN%2BmMuPbvePsVwAOJBaDxn58YRbDYLROzPiaCVK8AoCCFv%2BqNac8DQ0Yxjvhld50EIIDNIPZJ5OJKbhlgDABNRIswCNE0445v9qpTNhq1OUrAy%2FBIV8OT7ZV%2FUZfCg4cJECmZebLlKwfRZahQG3DzmnijOq6ZHYQcODZfxWEJdV7klkLRWJlL1sGn%2BU1ts4PAusDz1qL5edttclfqAwWAKwI6vE3CMoi5EP9fAJsb2zviEw1DMTgZw6%2F4HrSIjtTCCsKt8ZaGXcJX3VGG3bp%2FAt8ZI2Y8iZhTUetl6Vb33OXgZ60xx0pARAistZrF2BB8WZAgfpCwtKBI2n%2BQich7OzqEFjcSi6nxg95X7U16Uj1PeVDvBdv3xQzLYsBxV%2Bj15imN5Wtry8Ra7SIygQgc5gTvlYfJnzL6TS2QjcpUsjMOsuL8PD9T7i33EmiphVni4uRN2Js2eVo8aWIyYsU1FQvoc058Uy%2Fl7I1BjNR%2BRnglWrXba3dJwrT7vzSd%2FXKOZmqOp2CNr0xAQMi5JrcKJWZaO2VqLhupKgB%2FLTUyRsl%2FqypVq6tlMJy2mdOzk7BnHv3aGDkrgdWdyMWqQTeVN6U55dVAd%2FjMdBzEeLuUy2pyif6ZRC1pMr6%2F5IEz1YPf6c%2FXsxCPp4Qfs7Bd2pffbkMikxjirJmqZokwRSWF6Z08a2oBSnoE2jZAnTX5HQplmaRqt1guWM9iySdPYYvWebgt6IbgFpvsWzb9nrmpybZ69wyc01gQiSLHkZZcItwhS43bogZ5yalAlg8Yz%2BlKAG9s8oXERcgiMjR9dtvVU%2FoMTIb%2BgKw6CCkmG2hiXVgtB16PkGM9HDRZYnf0PMpETGPKLQNsm6%2FRxHs9KuMJvR7HuFGhCRB0%2Ba5dnqB81Hl1UOrD8Z63cOVD7mGGwb222kj1ZZDoCxhDmmCZJeDID2GkOwhUin4UIApPTQz5w0PPz9lBVF9nIKFpsYKnoVZH%2FVaZNKGLWnkeQRA50mqsAS%2BGRIvPENJrUv5ymWPJ%2FjXgEPpcCYkMrSK2ueDDT%2Bc4pqKRbJbBYDLdSHpPCaninLnA8AHChjcrNtox98twgODZZRATrxZjlbS8BpILvfk8cmvcCSZLXWADPgtR7xte6Vwu1NBMfVo0%2B1OPNgD2V7qJ8VrPX2UFHP3bE9lOvT5uowabc6LJ4l9H4Xp58qCtmuXSFR3O4IxvbOFl4Dtj6Y7fNVxU%2BD7bss26cAa7e2jzJGcihCi1QMhu84efsVJcNXr43kcDYt%2Bx%2FsXrvQ%2Bmh2T46nD%2FPdJ02AUkZwSjqpIG3udL47UMx%2FDqsrniDg0tSnrVg%2Fs9PlFS1LkubAVHTVTEV0JcHdTEUVUO6GqchSUFoOTEXVXfi6mIos2e7A3GrMcvM5WkJhSR7tBfMVbdcP4BlcVJagRVOgmtFulrCozyxFnXO9DJde2aUD4%2FARDjPW9Psm8ytY%2BB1VrqDR2iJWrmyZlDBi5S9ypRTyYmDtGuOQYNWgrO5VPgcfQtWpIwvVjvElqPek3LVUWLMvdlkZC%2Bac5%2FX0za7iJ3XhE38U%2FovLmWvrKodecmwvKafHKdZptFWx7Nbo4NwddHANM%2B3UdDYXdhIfFS2P%2FC3r1bb0eu8ytNGEXCXSkAiVj6TAjX%2FEKVVsRxSvNdqyCj4gjRYWq0j7RK%2FsdO6CQSM0pBEUEWlbFUhsTyHIiR1DIcXJzpGz0zvqtpBCTrkYCimaELQUNj5zIUUgC3rozScLuVT9ZihCQp1250B24obu3ISkrbK%2FrpB0p%2F3ZkssQfsDcnksOsZq6Jbayq3CCHGWINWitnRWrwihDrLj1Dw2vkvVWC3Dx%2F0Pnu6XVuY7ghMGDHZsOkfxygEPJ1MH4WpxxDv5f8uMT8F7w7%2F%2F5%2Fsfvd0UG%2F8FhXjYE6RmDE1voHI2KxHkMMqDCoZfyNEfP6BpPj7SXvvdMy0WK71RaknGuXI5xu42SXOhG1y8XyetYbrdhotexL9YucEpTPzn9gbFQ7hR3dGrIIF6l%2BJmCG6KgcWIhiD7TJFapURyxCgmLYeBUBoyrmKxkpYhbe1g4tIOwjFs%2FYi8RXCg8ElPlkehteSS2nM3VVf7PgXk5vGd%2B3swcmriElqYzNS576c6zXK02gwls%2FBnnCRAeogwoJ9fC%2Bnt%2FGk%2FRY2i2kwEeY2lcxpN%2BZ7hafdIT2io%2FCTfoPwnYTAb0ZvKKiG%2B7M6%2FIOjWvqJSNQruW7ZRHVWVGL%2Fxq5Lrmk1bsPSgBINZX2hFjzn3Sg%2BoHREZglRtIoX9s1YjItgEGrbZUkGph8%2FLAkyig5AW6P9v%2BjnK9%2FgQWogBGHhynCei7lYs6GBGtV6CRwSZi5gA70ANHdK9O94Dfi6JYrdF0Cpx9etrM1wV43N0UuIYPQFPEwI6ZD%2Bhk%2BMPUESdiUqCzbmfxSwb%2BWoNn3%2Fq3un23An7zKXbHruhURNSmIo9YKWjDbVHQckrf1lu7Up%2BimXhSlXT5ZLEu40W2HC8yGgr%2FXoscD9XFOl0z9mwylWNTjUZ7P6xgFSR2nQZ3bZmZYWC96pr16mDU7FuO2h7Dla1YK7gWKR%2B1qvmspYh2RQl%2BXxiu6KCsb6xEl0w5hHvmx6tsduQJ6V5g6coZrqrg9sGqnR1zsIf9Z%2FnYYQ%2FPznDlyNGugeHqNJHjjvkBzeF%2B9Au9s4XXgK2PZvsGtuPLt31nZ7hy5LDxwHB1inL6oEzHjhyqHhiuuoHWB7N77hnpcWj6B0ozcTQh%2F0N3fe2IBJCLT7kBX2472t58QQdk27SaG0PLYXfnxlTME3TDuePa50e7IQLdNO0PCXTU6S0e6Xdu4F0G2q190X5Wgilfnt5Co2eUabzXCuLccsChhwoWHLLgvKoX9ZGWqrHMsxp1UulDIIjrZBz5LjzyxFRAmlHG6K5s8Q7t8VYFPfAXmFKkKam7CPKuU4NSikHcCrbun6o8S6kAvPJsi6vPuQi3IVBQ9ZHKASg3pEJoK24rFWh7SqQTkGCU1R3gG1QUHvRVrbbJ9hfsZvszRZ16a56mVDvQms7ZtObFqzkocFHVbUdI%2B6u6rfG409nIktzOYrUHh9gPQSX2w910z6sl5eDnaVrSHNTkLpVSoyZt23BLXmLv1aR3fudyW%2FO01RC%2BZR6jIS5e9cK6LDokJ9EKmw7Z91e93XmT1t7upHdWRalaSe54RaliTmREbWwIvwdL46Btd2imGm1r6EazFNSU5EMc6RulG7Sni8EHnV8Zw%2BlrXhPv0MIXSoTfoAYMgn01YEUZd0caUA5NjhB4qqY4Ny%2FpiKBrZ2WkuvCRg1e2KdJkCWCAIKt1l9Owg8%2FHLK0m7yhY0FQ1je7h6QxgM8%2BgFdmqjDxaLb5mM6jWJ%2F8F)

### 1. 工程结构

```java
└── src
    ├── main
    │   └── java
    │      └── pub.lhp.design.domain
    │          ├── model
    │          │   ├── aggregates
    │          │   │   └── TreeRich.java
    │          │   └── vo
    │          │       ├── EngineResult.java
    │          │       ├── TreeNode.java
    │          │       ├── TreeNodeLink.java    
    │          │       └── TreeRoot.java	
    │          └── service
    │              ├── engine
    │              │   ├── impl	
    │              │   │   └── TreeEngineHandle.java
    │              │   ├── EngineBase.java 
    │              │   ├── EngineConfig.java
    │              │   └── IEngine.java	
    │              └── logic
    │                  ├── impl	
    │                  │   ├── UserAgeFilter.java
    │                  │   └── UserGenderFilter.java
    │                  └── LogicFilter.java	
    └── test
         └── java
             └── pub.lhp.design.test
                 └── ApiTest.java
```

### 2. 模型结构

![[Pasted image 20241015113926.png]]

- 首先可以看下黑色框框的模拟指导树结构；`1`、`11`、`12`、`111`、`112`、`121`、`122`，这是一组树结构的 ID，并由节点串联组合出一棵关系树。
- 接下来是类图部分，左侧是从 `LogicFilter` 开始定义适配的决策过滤器，`BaseLogic` 是对接口的实现，提供最基本的通用方法。`UserAgeFilter`、`UserGenerFilter`，是两个具体的实现类用于判断 `年龄` 和 `性别`。
- 最后则是对这颗可以被组织出来的决策树，进行执行的引擎。同样定义了引擎接口和基础的配置，在配置里面设定了需要的模式决策节点。

### 3. 代码实现

#### 3.1 基础对象

| 包路径              | 类            | 介绍            |
| ---------------- | ------------ | ------------- |
| model.aggregates | TreeRich     | 聚合对象，包含组织树信息  |
| model.vo         | EngineResult | 决策返回对象信息      |
| model.vo         | TreeNode     | 树节点；子叶节点、果实节点 |
| model.vo         | TreeNodeLink | 树节点链接链路       |
| model.vo         | TreeRoot     | 树根信息          |

以上这部分简单介绍，不包含逻辑只是各项必要属性的 `get/set`。

#### 3.2 树节点逻辑过滤器接口

- 这一部分定义了适配的通用接口，逻辑决策器、获取决策值，让每一个提供决策能力的节点都必须实现此接口，保证统一性。

```java
public interface LogicFilter {

    /**
     * 逻辑决策器
     *
     * @param matterValue          决策值
     * @param treeNodeLineInfoList 决策节点
     * @return 下一个节点Id
     */
    Long filter(String matterValue, List<TreeNodeLink> treeNodeLineInfoList);

    /**
     * 获取决策值
     *
     * @param decisionMatter 决策物料
     * @return 决策值
     */
    String matterValue(Long treeId, String userId, Map<String, String> decisionMatter);

}
```

#### 3.3 决策抽象类提供基础服务

- 在抽象方法中实现了接口方法，同时定义了基本的决策方法；`1、2、3、4、5`，`等于、小于、大于、小于等于、大于等于` 的判断逻辑。
- 同时定义了抽象方法，让每一个实现接口的类都必须按照规则提供 `决策值`，这个决策值用于做逻辑比对。

```java
public abstract class BaseLogic implements LogicFilter {

    @Override
    public Long filter(String matterValue, List<TreeNodeLink> treeNodeLinkList) {
        for (TreeNodeLink nodeLine : treeNodeLinkList) {
            if (decisionLogic(matterValue, nodeLine)) return nodeLine.getNodeIdTo();
        }
        return 0L;
    }

    @Override
    public abstract String matterValue(Long treeId, String userId, Map<String, String> decisionMatter);

    private boolean decisionLogic(String matterValue, TreeNodeLink nodeLink) {
        switch (nodeLink.getRuleLimitType()) {
            case 1:
                return matterValue.equals(nodeLink.getRuleLimitValue());
            case 2:
                return Double.parseDouble(matterValue) > Double.parseDouble(nodeLink.getRuleLimitValue());
            case 3:
                return Double.parseDouble(matterValue) < Double.parseDouble(nodeLink.getRuleLimitValue());
            case 4:
                return Double.parseDouble(matterValue) <= Double.parseDouble(nodeLink.getRuleLimitValue());
            case 5:
                return Double.parseDouble(matterValue) >= Double.parseDouble(nodeLink.getRuleLimitValue());
            default:
                return false;
        }
    }

}
```

#### 3.4 树节点逻辑实现类

年龄节点

```java
public class UserAgeFilter extends BaseLogic {

    @Override
    public String matterValue(Long treeId, String userId, Map<String, String> decisionMatter) {
        return decisionMatter.get("age");
    }

}
```

性别节点

```java
public class UserGenderFilter extends BaseLogic {

    @Override
    public String matterValue(Long treeId, String userId, Map<String, String> decisionMatter) {
        return decisionMatter.get("gender");
    }

}
```

- 以上两个决策逻辑的节点获取值的方式都非常简单，只是获取用户的入参即可。实际的业务开发可以从数据库、RPC 接口、缓存运算等各种方式获取。

#### 3.5 决策引擎接口定义

- 对于使用方来说也同样需要定义统一的接口操作，这样的好处非常方便后续拓展出不同类型的决策引擎，也就是可以建造不同的决策工厂。

```java
public interface IEngine {

    EngineResult process(final Long treeId, final String userId, TreeRich treeRich, final Map<String, String> decisionMatter);

}
```

#### 3.6 决策节点配置

```java
public class EngineConfig {

    static Map<String, LogicFilter> logicFilterMap;

    static {
        logicFilterMap = new ConcurrentHashMap<>();
        logicFilterMap.put("userAge", new UserAgeFilter());
        logicFilterMap.put("userGender", new UserGenderFilter());
    }

    public Map<String, LogicFilter> getLogicFilterMap() {
        return logicFilterMap;
    }

    public void setLogicFilterMap(Map<String, LogicFilter> logicFilterMap) {
        this.logicFilterMap = logicFilterMap;
    }

}
```

- 在这里将可提供服务的决策节点配置到 `map` 结构中，对于这样的 `map` 结构可以抽取到数据库中，那么就可以非常方便的管理。

#### 3.7 基础决策引擎功能

```java
public abstract class EngineBase extends EngineConfig implements IEngine {

    private Logger logger = LoggerFactory.getLogger(EngineBase.class);

    @Override
    public abstract EngineResult process(Long treeId, String userId, TreeRich treeRich, Map<String, String> decisionMatter);

    protected TreeNode engineDecisionMaker(TreeRich treeRich, Long treeId, String userId, Map<String, String> decisionMatter) {
        TreeRoot treeRoot = treeRich.getTreeRoot();
        Map<Long, TreeNode> treeNodeMap = treeRich.getTreeNodeMap();
        // 规则树根ID
        Long rootNodeId = treeRoot.getTreeRootNodeId();
        TreeNode treeNodeInfo = treeNodeMap.get(rootNodeId);
        //节点类型[NodeType]；1子叶、2果实
        while (treeNodeInfo.getNodeType().equals(1)) {
            String ruleKey = treeNodeInfo.getRuleKey();
            LogicFilter logicFilter = logicFilterMap.get(ruleKey);
            String matterValue = logicFilter.matterValue(treeId, userId, decisionMatter);
            Long nextNode = logicFilter.filter(matterValue, treeNodeInfo.getTreeNodeLinkList());
            treeNodeInfo = treeNodeMap.get(nextNode);
            logger.info("决策树引擎=>{} userId：{} treeId：{} treeNode：{} ruleKey：{} matterValue：{}", treeRoot.getTreeName(), userId, treeId, treeNodeInfo.getTreeNodeId(), ruleKey, matterValue);
        }
        return treeNodeInfo;
    }

}
```

- 这里主要提供决策树流程的处理过程，有点像通过链路的关系（性别、年龄）在二叉树中寻找果实节点的过程。
- 同时提供一个抽象方法，执行决策流程的方法供外部去做具体的实现。

#### 3.8 决策引擎的实现

```java
public class TreeEngineHandle extends EngineBase {

    @Override
    public EngineResult process(Long treeId, String userId, TreeRich treeRich, Map<String, String> decisionMatter) {
        // 决策流程
        TreeNode treeNode = engineDecisionMaker(treeRich, treeId, userId, decisionMatter);
        // 决策结果
        return new EngineResult(userId, treeId, treeNode.getTreeNodeId(), treeNode.getNodeValue());
    }

}
```

- 这里对于决策引擎的实现就非常简单了，通过传递进来的必要信息：决策树信息、决策物料值，来做具体的树形结构决策。

### 4. 测试验证

#### 4.1 组装树关系

```java
@Before
public void init() {
    // 节点：1
    TreeNode treeNode_01 = new TreeNode();
    treeNode_01.setTreeId(10001L);
    treeNode_01.setTreeNodeId(1L);
    treeNode_01.setNodeType(1);
    treeNode_01.setNodeValue(null);
    treeNode_01.setRuleKey("userGender");
    treeNode_01.setRuleDesc("用户性别[男/女]");
    // 链接：1->11
    TreeNodeLink treeNodeLink_11 = new TreeNodeLink();
    treeNodeLink_11.setNodeIdFrom(1L);
    treeNodeLink_11.setNodeIdTo(11L);
    treeNodeLink_11.setRuleLimitType(1);
    treeNodeLink_11.setRuleLimitValue("man");
    // 链接：1->12
    TreeNodeLink treeNodeLink_12 = new TreeNodeLink();
    treeNodeLink_12.setNodeIdTo(1L);
    treeNodeLink_12.setNodeIdTo(12L);
    treeNodeLink_12.setRuleLimitType(1);
    treeNodeLink_12.setRuleLimitValue("woman");
    List<TreeNodeLink> treeNodeLinkList_1 = new ArrayList<>();
    treeNodeLinkList_1.add(treeNodeLink_11);
    treeNodeLinkList_1.add(treeNodeLink_12);
    treeNode_01.setTreeNodeLinkList(treeNodeLinkList_1);
    // 节点：11
    TreeNode treeNode_11 = new TreeNode();
    treeNode_11.setTreeId(10001L);
    treeNode_11.setTreeNodeId(11L);
    treeNode_11.setNodeType(1);
    treeNode_11.setNodeValue(null);
    treeNode_11.setRuleKey("userAge");
    treeNode_11.setRuleDesc("用户年龄");
    // 链接：11->111
    TreeNodeLink treeNodeLink_111 = new TreeNodeLink();
    treeNodeLink_111.setNodeIdFrom(11L);
    treeNodeLink_111.setNodeIdTo(111L);
    treeNodeLink_111.setRuleLimitType(3);
    treeNodeLink_111.setRuleLimitValue("25");
    // 链接：11->112
    TreeNodeLink treeNodeLink_112 = new TreeNodeLink();
    treeNodeLink_112.setNodeIdFrom(11L);
    treeNodeLink_112.setNodeIdTo(112L);
    treeNodeLink_112.setRuleLimitType(5);
    treeNodeLink_112.setRuleLimitValue("25");
    List<TreeNodeLink> treeNodeLinkList_11 = new ArrayList<>();
    treeNodeLinkList_11.add(treeNodeLink_111);
    treeNodeLinkList_11.add(treeNodeLink_112);
    treeNode_11.setTreeNodeLinkList(treeNodeLinkList_11);
    // 节点：12
    TreeNode treeNode_12 = new TreeNode();
    treeNode_12.setTreeId(10001L);
    treeNode_12.setTreeNodeId(12L);
    treeNode_12.setNodeType(1);
    treeNode_12.setNodeValue(null);
    treeNode_12.setRuleKey("userAge");
    treeNode_12.setRuleDesc("用户年龄");
    // 链接：12->121
    TreeNodeLink treeNodeLink_121 = new TreeNodeLink();
    treeNodeLink_121.setNodeIdFrom(12L);
    treeNodeLink_121.setNodeIdTo(121L);
    treeNodeLink_121.setRuleLimitType(3);
    treeNodeLink_121.setRuleLimitValue("25");
    // 链接：12->122
    TreeNodeLink treeNodeLink_122 = new TreeNodeLink();
    treeNodeLink_122.setNodeIdFrom(12L);
    treeNodeLink_122.setNodeIdTo(122L);
    treeNodeLink_122.setRuleLimitType(5);
    treeNodeLink_122.setRuleLimitValue("25");
    List<TreeNodeLink> treeNodeLinkList_12 = new ArrayList<>();
    treeNodeLinkList_12.add(treeNodeLink_121);
    treeNodeLinkList_12.add(treeNodeLink_122);
    treeNode_12.setTreeNodeLinkList(treeNodeLinkList_12);
    // 节点：111
    TreeNode treeNode_111 = new TreeNode();
    treeNode_111.setTreeId(10001L);
    treeNode_111.setTreeNodeId(111L);
    treeNode_111.setNodeType(2);
    treeNode_111.setNodeValue("果实A");
    // 节点：112
    TreeNode treeNode_112 = new TreeNode();
    treeNode_112.setTreeId(10001L);
    treeNode_112.setTreeNodeId(112L);
    treeNode_112.setNodeType(2);
    treeNode_112.setNodeValue("果实B");
    // 节点：121
    TreeNode treeNode_121 = new TreeNode();
    treeNode_121.setTreeId(10001L);
    treeNode_121.setTreeNodeId(121L);
    treeNode_121.setNodeType(2);
    treeNode_121.setNodeValue("果实C");
    // 节点：122
    TreeNode treeNode_122 = new TreeNode();
    treeNode_122.setTreeId(10001L);
    treeNode_122.setTreeNodeId(122L);
    treeNode_122.setNodeType(2);
    treeNode_122.setNodeValue("果实D");
    // 树根
    TreeRoot treeRoot = new TreeRoot();
    treeRoot.setTreeId(10001L);
    treeRoot.setTreeRootNodeId(1L);
    treeRoot.setTreeName("规则决策树");
    Map<Long, TreeNode> treeNodeMap = new HashMap<>();
    treeNodeMap.put(1L, treeNode_01);
    treeNodeMap.put(11L, treeNode_11);
    treeNodeMap.put(12L, treeNode_12);
    treeNodeMap.put(111L, treeNode_111);
    treeNodeMap.put(112L, treeNode_112);
    treeNodeMap.put(121L, treeNode_121);
    treeNodeMap.put(122L, treeNode_122);
    treeRich = new TreeRich(treeRoot, treeNodeMap);
}
```

![[Pasted image 20241015220706.png]]

![[Pasted image 20241015125847.png]]

- **重要**，这一部分是组合模式非常重要的使用，在我们已经建造好的决策树关系下，可以创建出树的各个节点，以及对节点间使用链路进行串联。
- 即使后续你需要做任何业务的扩展都可以在里面添加相应的节点，并做动态化的配置。
- 关于这部分手动组合的方式可以提取到数据库中，那么也就可以扩展到图形界面的进行配置操作。

#### 3.2 编写测试类

```java
@Test
public void test_tree() {
    logger.info("决策树组合结构信息：\r\n" + JSON.toJSONString(treeRich));
    
    IEngine treeEngineHandle = new TreeEngineHandle();
    Map<String, String> decisionMatter = new HashMap<>();
    decisionMatter.put("gender", "man");
    decisionMatter.put("age", "29");
    
    EngineResult result = treeEngineHandle.process(10001L, "Oli09pLkdjh", treeRich, decisionMatter);
    
    logger.info("测试结果：{}", JSON.toJSONString(result));
}
```

- 在这里提供了调用的通过组织模式创建出来的流程决策树，调用的时候传入了决策树的 ID，那么如果是业务开发中就可以方便的解耦决策树与业务的绑定关系，按需传入决策树 ID 即可。
- 此外入参我们还提供了需要处理；`男`(man)、`年龄`(29 岁)，的参数信息。

#### 4.3 测试结果

```java
23:35:05.711 [main] INFO  o.i.d.d.d.service.engine.EngineBase - 决策树引擎=>规则决策树 userId：Oli09pLkdjh treeId：10001 treeNode：11 ruleKey：userGender matterValue：man
23:35:05.712 [main] INFO  o.i.d.d.d.service.engine.EngineBase - 决策树引擎=>规则决策树 userId：Oli09pLkdjh treeId：10001 treeNode：112 ruleKey：userAge matterValue：29
23:35:05.715 [main] INFO  org.itstack.demo.design.test.ApiTest - 测试结果：{"nodeId":112,"nodeValue":"果实B","success":true,"treeId":10001,"userId":"Oli09pLkdjh"}

Process finished with exit code 0
```

## 六、总结

- 从以上的决策树场景来看，组合模式主要解决的是一系列简单逻辑节点或者扩展的复杂逻辑节点在不同结构的组织下，对于外部的调用是仍然可以非常简单的。
- 这部分设计模式保证了开闭原则，无需更改模型结构你就可以提供新的逻辑节点的使用并配合组织出新的关系树。但如果是一些功能差异化非常大的接口进行包装就会变得比较困难，但也不是不能很好的处理，只不过需要做一些适配和特定化的开发。
- 很多时候因为你的极致追求和稍有倔强的工匠精神，即使在面对同样的业务需求，你能完成出最好的代码结构和最易于扩展的技术架构。`不要被远不能给你指导提升能力的影响到放弃自己的追求！`
