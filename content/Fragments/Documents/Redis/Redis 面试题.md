## Redis 为什么这么快？

主要有 3 个方面的原因，分别是存储方式、优秀的线程模型以及 IO 模型、高效的数据结构。

### 1. 存储方式

Redis 的存储是**基于内存**的，直接访问内存的速度是远远大于访问磁盘的速度的。其访问的速度差了一千倍左右。除了一些场景，比如说持久化，Redis 很少需要与磁盘进行交互，大多数时候 Redis 的读写是基于内存的，因此其效率较高。

### 2.优秀的线程模型以及 IO 模型

Redis 使用**单个主线程**来执行命令，不需要进行线程切换，避免了上下文切换带来的性能开销，大大提高了 Redis 的运行效率和响应速度。

Redis 采用了 **I/O 多路复用技术**，实现了单个线程同时处理多个客户端连接的能力，从而提高 Redis 的并发能力。

### 3. 高效的数据结构

Redis 本身提供了丰富的数据结构，比如 String、Hash、Zset 等，这些数据结构大多操作的时间复杂度都为 O(1)。

---

## Redis 常见的数据类型有哪些？

Redis 常见的数据结构主要有五种，这五种类型分别为：String(字符串)、List(列表)、Hash、Set(集合)、Zset(有序集合，也叫 sorted set)。

![Snipaste_2024-05-05_21-01-31.jpg|525](https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/Snipaste_2024-05-05_21-01-31_mianshiya.jpg)

随着 Redis 版本的更新，后面又增加了 4 种**高级**数据类型：BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。

Redis 9 种常见的基本数据类型应用场景如下：

- String ：缓存对象、计数器、分布式锁、分布式 session 等
- List：阻塞队列、消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等
- Hash：缓存对象、购物车等
- Set：集合聚合计算（并集、交集、差集）的场景，如点赞、共同关注、收藏等
- Zset：最典型的就是排行榜，这个也是面试中经常问到的点
- BitMap（2.2 版新增）：主要有 0 和 1 两种状态，可以用于签到统计、用户登录态判断等
- HyperLogLog（2.8 版新增）：海量数据基数统计的场景，有一定的误差，可以根据场景选择使用，常用于网页 PV、UV 的统计
- GEO（3.2 版新增）：存储地理位置信息的场景，比如说百度地图、高德地图、附近的人等
- Stream（5.0 版新增）：这个主要就是消息队列了，可以实现一个简单的消息，其相比 list 多了两个特性，分别是自动生成全局唯一消息 ID 以及支持以消费组形式消费数据（同一个消息可被分发给多个单消费者和消费者组），相比 pub/sub 它是可以被持久化。

---

### Redis 为什么要设计成单线程？6.0 不是变成多线程了吗？

我们所说的 Redis 单线程，主要指的是 Redis **网络 I/O** 和**键值对读写**这些操作是由一个线程完成的。（持久化、集群等机制其实是有后台线程执行的）

Redis 之所以在前期并没有在**网络请求模块**和**数据操作模块**中使用多线程模型，其主要原因如下：

1. Redis 的操作是基于内存的，其大多数操作的性能瓶颈主要不是 CPU 导致的
2. 使用单线程模型，代码简便的同时也减少了线程上下文切换带来的性能开销，这也是 Redis 为什么快的原因之一
3. Redis 在单线程的情况下，使用 I/O 多路复用模型就可以提高 Redis 的 I/O 利用率了

不过 Redis 并不是一直都单线程的，在 4.0 之后就开始引入了多线程指令，6.0 之后便正式引入了多线程的机制，不过 **这里的多线程其只是针对网络请求过程使用多线程，其对于数据读写命令的处理依旧是单线程的**。

那为什么 Redis 前期不使用多线程的方式，等到 6.0 却又引入呢？

主要是因为我们对 Redis 的性能有了更高的要求，因为随着业务愈加复杂，公司需要的 QPS 就越高了，为了提升 QPS ，最直接的做法就是搭建 Redis 的集群，即提高 Redis 的机器数，但是这种做法的资源消耗是巨大的。

而 Redis 单线程执行命令的性能瓶颈在网络 I/O ，虽然它采用了多路复用技术，但 **I/O 多路复用模型的本质就是同步阻塞型 IO**。

下面列举一下 IO 多路复用的图，帮助大家理解一下：

![Snipaste_2024-05-04_21-51-07.jpg|475](https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/Snipaste_2024-05-04_21-51-07_mianshiya.jpg)

从上面这个图中我们可以看到，I/O 多路复用在处理网络请求的时候，其无论是调用 epoll 还是其他函数，其过程都是阻塞的，即处理网络请求的这个过程都会阻塞线程，**如果并发量很高的话，这个过程可能会成为瓶颈**。

综上所示，我们可以发现，单线程加上网络 IO 模型的设计并不能很好地解决网络 IO 瓶颈的问题，这个时候就可以考虑利用 CPU 的多核优势，即利用多线程处理网络请求的方式来提高效率，然后对于读写命令， Redis 依旧采用单线程命令。

![[Pasted image 20240731212559.png|525]]

这里可能会有另外一个问题：

---

### Redis 引入多线程之后，有没有带来什么线程安全问题呢？

没有，因为 Redis 6.0 只有针对网络请求模块采用的是多线程，对于读写部分还是采用单线程，所以所谓的线程安全问题就不存在了。

---
